スーパー支払い君.com

「※実施開始前の環境構築や仕様確認等の準備時間は、所要時間に含めません」とあったのでREADMEに記載の詳細設計は時間に含めず先に行っておく。

## 動作方法
- go run main.goして、postmanなどでリクエストを送る(UTC時間で送る)
  - UT等書きたいが時間がなさそう。

## test

- 以下コマンドで簡単なe2eテストが可能
- テストケースはe2e_test.go参照

```
go test -v
```

## やること
1. 請求書の登録をする
2. 指定期間内の請求書一覧を取得する

## 「請求書の登録をする」

```
POST: /api/invoices
```

### 処理内容
1. reqのバリデーションを行う
   1. reqの各項目のバリデーションを適宜行う。
2. 請求金額を計算する
   1. 計算式： 支払い金額 + (支払い金額 * 手数料(0.04) * 消費税(1.10)) ※消費税は手数料にのみかかる
   2. 手数料、消費税は他のusecaseでも使用されうるかつ変更可能性があるためdomain管理する。
3. 請求書データの作成する
   1. 「請求書データテーブル(invoices)」に保存する
   2.  ステータスは「未処理」で登録 ※ステータスもdomain管理する。

### 想定request
```json
{
    "company_uuid": "00000000-0000-0000-0000-000000000000",
    "client_id": "00000000-0000-0000-0000-000000000000",
    "amount": 10000,
    "due_date": "2024-01-20",
}
```

### 想定response
無(status codeのみ)
```
200: OK
400: Bad request - アプリケーションで想定されうるエラーの場合
500: internal server error - サーバーエラーが発生した場合
```

## 「指定期間内の請求書一覧を取得する」

```
GET: /api/invoices
```

### 処理内容
1. reqのバリデーションを行う
   1. from_date, to_dateが無効、フォーマットが不正等
2. reqで受け取ったfrom_dateとto_dateの範囲内で支払い期限が設定されている請求書を「請求書データテーブル(invoices)」から取得する
3. 該当する請求書データをリストとして返す

### 想定request
```
GET: /api/invoices?from_date=2024-01-01&to_date=2024-01-30
```

bodyは無

### 想定response
```json
[
    {
        "uuid": "00000000-0000-0000-0000-000000000000",
        "company_uuid": "00000000-0000-0000-0000-000000000000",
        "client_uuid": "00000000-0000-0000-0000-000000000000",
        "issued_date": "2024-01-10",
        "amount": 10000,
        "fee": 400,
        "fee_rate": 0.04,
        "tax": 440,
        "tax_rate": 1.10,
        "total_amount": 10440,
        "due_date": "2024-01-20",
        "status": "未処理"
    },
    {
        "uuid": 1,
        "company_uuid": "00000000-0000-0000-0000-000000000000",
    ...
    },
    ...
]
```

```
200: OK
400: Bad request - アプリケーションで想定されうるエラーの場合
500: internal server error - サーバーエラーが発生した場合
```

## DB設計
- 仕様書に記載の5つのデータモデルをそのままテーブルにする
- テーブル詳細はadapter/sql.goのsql参照
- 時間があればmermaidでER図を作成する（今回のusecaseではほぼ請求書データテーブル(invoices)しか使用しないのでここの設計はできるだけ時間をかけない。）

## アーキテクチャ
クリーンアーキテクチャを採用している（つもり）

1. adapter層
   1. 外部接続を担当します。
   2. 今回はRDSへの接続の責務を持ちます。
2. db層
   1. 実際のDBデータが入っています。(ignoreしています)
3. di層
   1. 依存性注入を行います。
4. router層
   1. routingを行います。
5. handler層
   1. routingから呼び出されます。
   2. requestのスキャンや型変換、responseの生成の責務を持ちます。
6. usecase層
   1. アプリケーションロジックを実装します。domainロジックとは分離します。
7. domain層
   1. domain/vo
      1. value objectの管理
      2. 値の一貫性の確保、複数のentityが同じVOを共有できます。entityから値に関するロジックを分離します。
   2. domain/entity
      1. entityを記載します。domainロジックを持ちます。
   3. domain/repository層
      1. DB操作メソッドinterfaceを提供します。
8. infra層
   1. repository層で提供されるinterfaceの具体の実装の責務を持ちます。

## 技術選定
1. sqlite
   1. postgresql等がbetterだが時間が短く、環境変数用意などのセットアップに時間をかけないため
   2. ORマッパー(GORM等)は使わず生のsqlを書く（ただの好み）
2. echo
   1. routingやquery parameterなどのsqanが簡単なため

## その他のサービスの特徴

「この項目は今回のusecaseでは実装はしないが必要であれば考慮しながら実装する」

- 期日に残高がなくとも自動的に銀行振り込みを行うことができる
- 現金の支出を最大一ヶ月遅らせることができる

## その他考慮事項

1. 認証
   1. API実装の中で認証せず、別domainで行う方法がbetterと考えここでは実装しない
      1. JWT認証等の手法を用いてauthentication domainで認証を行う
2. 認可
   1. reqヘッダーに認可UUIDなどを詰め、API実行時に認可する
      1. これはこのAPIで行うべきであるがデータモデルに認可に関する定義はなく時間もないので見送る
3. DI
   1. 依存性の注入は行う
4. テストコード
   1. クリーンアーキテクチャっぽいものを採用しているので層毎のUTは書くべき
      1. 時間があればE2Eテストは実装する
5. 秘匿情報
   1. loggingの実装をする際には特に注意する。秘匿情報に当たるものはマスキング等を行う。
   2. データ識別にはuuidを使用する。idに比べて衝突可能性が低くセキュリティ面でも良いと考えたため
   3. また、必要でない限り変数や構造体などはlocal情報として保持する
6. DDD
   1. 採用している（つもり）。
   2. 集約を意識するためtransactionはusecase層に書く。(今回のcaseでは集約はほぼ考えなくて良い)
7. 金額などの少数の考え方
   1. DBでは一旦整数値10桁小数値2桁まで受け入れ可能にしておく。
   2. アプリケーションコードの少数の丸め誤差は何桁かなどdomainの決めによるが、実装やテストしながら考える。。
8. 時間計算について
   1. リクエストも含め全てUTCで行う。
   2. ヘッダーにクライアントのtimezoneを含めたいが、大変なため